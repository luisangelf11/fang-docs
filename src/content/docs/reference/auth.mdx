---
title: "Auth API: Fang JS + Prisma ORM"
description: Un ejemplo pr√°ctico de autenticaci√≥n utilizando Fang JS, Prisma ORM.
---

import { Aside, Steps, Card } from "@astrojs/starlight/components";

¬øQuieres ver de lo que es capaz **Fang JS** cuando se ensucia las manos? En este ejemplo, construiremos una API Rest b√°sica, que nos permita hacer un auth de usuarios, para ello usaremos la arquitectura recomendada. En este ejemplo veremos:

- **Persistencia:** Prisma ORM sobre una base de datos PostgreSQL/SQLite.
- **Validaci√≥n:** Esquemas de Zod importados desde `@fang-js/fang/zod`.
- **Seguridad:** Protecci√≥n de rutas con auth y uso de JWT.
- **Arquitectura:** Separaci√≥n clara entre Controladores y Servicios.

## Requisitos Previos

Antes de empezar, aseg√∫rate de tener instalado Drizzle en tu proyecto:

```bash
npm install prisma @types/node @types/pg --save-dev
npm install @prisma/client @prisma/adapter-pg pg
npx prisma init --db --output ../generated/prisma
```

## Implementaci√≥n

A continuaci√≥n, se muestra la implementaci√≥n de la API. Observa c√≥mo el Context fluye a trav√©s de los servicios y c√≥mo el middleware de auth protege las rutas sensibles de forma limpia.

### Arquitectura del proyecto

```
‚îú‚îÄ‚îÄ üìÅ prisma
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ migrations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ 20260202181730_init
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ migration.sql
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ‚öôÔ∏è migration_lock.toml
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ schema.prisma
‚îú‚îÄ‚îÄ üìÅ src
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ auth
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ auth-controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ auth-schema.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ auth-service.ts
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ config
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ keys.ts
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ lib
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ prisma.ts
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ index.ts
‚îú‚îÄ‚îÄ ‚öôÔ∏è .gitignore
‚îú‚îÄ‚îÄ üìÑ dev.db
‚îú‚îÄ‚îÄ ‚öôÔ∏è package-lock.json
‚îú‚îÄ‚îÄ ‚öôÔ∏è package.json
‚îú‚îÄ‚îÄ üìÑ prisma.config.ts
‚îî‚îÄ‚îÄ ‚öôÔ∏è tsconfig.json
```

### Archivo principal (index.ts)

```typescript
import { Fang } from "@fang-js/fang";
import {
  BadRequestException,
  NotFoundException,
  UnauthorizedException,
} from "@fang-js/fang/exceptions";
import { cors } from "@fang-js/fang/middlewares";
import { methods } from "@fang-js/fang/types";
import { AuthController } from "./auth/auth-controller.js";

const app = new Fang();

app.use(
  cors({
    origin: "*",
    methods: [
      methods.GET,
      methods.POST,
      methods.PUT,
      methods.DELETE,
      methods.PATCH,
    ],
  }),
);

app.get("/", (ctx) => {
  ctx.ok({ message: "Hello World from fang" });
});

app.group("/auth", AuthController.register);

app.onError((error, ctx) => {
  if (error.message === "Invalid body schema")
    return ctx.badRequest({ message: error.message, status: 400 });

  if (error instanceof UnauthorizedException)
    return ctx.unauthorized({
      success: false,
      message: error.message,
      data: null,
    });

  if (error instanceof NotFoundException)
    return ctx.notFound({
      success: false,
      message: error.message,
      data: null,
    });

  if (error instanceof BadRequestException)
    return ctx.badRequest({
      success: false,
      message: error.message,
      data: null,
    });

  return ctx.internalError({
    success: false,
    message: error.message,
    data: null,
  });
});

app.listen();
```

### Controlador de Productos

```typescript
import { Controller, RouteGroup } from "@fang-js/fang";
import { AuthService } from "./auth-service.js";
import { auth } from "@fang-js/fang/middlewares";
import { JWT_SECRET } from "../config/keys.js";

@Controller
export class AuthController {
  static register(group: RouteGroup) {
    const authService = new AuthService();

    group.post("/register", authService.registerUser);
    group.post("/login", authService.login);
    group.get("/profile", auth(JWT_SECRET), authService.getProfile);
  }
}
```

### Esquema del auth

```typescript
import { z } from "@fang-js/fang/zod";

export const userCreateSchema = z.object({
  name: z.string(),
  email: z.string(),
  password: z.string().min(8),
});

export const authSchema = z.object({
  email: z.string(),
  password: z.string().min(8),
});
```

### Servicio de Auth

```typescript
import { BaseService, Context, Service } from "@fang-js/fang";
import { prisma } from "../lib/prisma.js";
import { generateHash, signJwt, verifyHash } from "@fang-js/fang/security";
import { TokenExpiration } from "@fang-js/fang/types";
import { authSchema, userCreateSchema } from "./auth-schema.js";
import { JWT_SECRET } from "../config/keys.js";
import {
  BadRequestException,
  NotFoundException,
  UnauthorizedException,
} from "@fang-js/fang/exceptions";

@Service
export class AuthService extends BaseService {
  async registerUser(ctx: Context) {
    const body = await ctx.body(userCreateSchema);
    const userExists = await prisma.user.findUnique({
      where: { email: body.email },
    });

    if (userExists) throw new BadRequestException("User already exists");

    const hash = await generateHash(body.password);
    const newUser = await prisma.user.create({
      data: { name: body.name, email: body.email, password: hash },
    });
    const { password, ...result } = newUser;
    ctx.created({ user: result });
  }

  async login(ctx: Context) {
    const { email, password } = await ctx.body(authSchema);
    const user = await prisma.user.findUnique({ where: { email } });

    if (!user) throw new UnauthorizedException("Invalid credentials");

    const match = await verifyHash(password, user.password);
    if (!match) throw new UnauthorizedException("Invalid credentials");

    const jwt = await signJwt(
      { id: user.id, email: user.email },
      {
        expiresIn: TokenExpiration.OneHour,
        secret: JWT_SECRET,
      },
    );
    ctx.json({ success: "Welcome!", token: jwt });
  }

  async getProfile(ctx: Context) {
    const user = await prisma.user.findFirst({
      where: { id: Number(ctx.state.user.id) },
      select: {
        id: true,
        name: true,
        email: true,
        createdAt: true,
      },
    });
    if (!user) throw new NotFoundException("User not found");

    ctx.json({ user });
  }
}
```

### Configuraci√≥n de Prisma

```typescript
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";
import { PrismaClient } from "@prisma/client";

const connectionString = `${process.env.DATABASE_URL}`;

const adapter = new PrismaBetterSqlite3({ url: connectionString });
const prisma = new PrismaClient({ adapter });

export { prisma };
```

## Puntos Clave del Ejemplo

<Card title="Cero Fricci√≥n" icon="rocket">
  {" "}
  Nota c√≥mo el middleware de auth inyecta autom√°ticamente al usuario en
  ctx.state.user, disponible para cualquier ruta posterior.{" "}
</Card>

<Card title="Seguridad de Hashing" icon="shieldCheck">
  {" "}
  Las contrase√±as no se guardan en texto plano; usamos generateHash de Fang para
  aplicar scrypt antes de persistir en Prisma.{" "}
</Card>

<Card title="Respuestas Sem√°nticas" icon="approve-check">
  {" "}
  En lugar de configurar cabeceras manualmente, podr√≠amos usar tambi√©n ctx.ok(),
  ctx.created() y las excepciones como NotFoundException.{" "}
</Card>
